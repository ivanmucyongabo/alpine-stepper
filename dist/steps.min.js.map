{"version":3,"file":"steps.min.js","sources":["../src/index.js"],"sourcesContent":["\"use strict\";\n/**\n * A controller for stepwise UI components.\n * @module AlpineSteps\n */\n\n/**\n * Class for stepwise UI controller\n *\n * @property {string[]|Object[]} steps - Step items.\n * @property {string} currentStep - The name of the active step item.\n * @property {boolean} circular - If circular indexing is enabled.\n */\nexport class StepsController {\n  /**\n   * Create a controller\n   * @param {string[]|Object[]} model - Step items.\n   * @param {string} model[].name - The name of the step, if an array of Objects.\n   * @param {boolean} circular - Allow circular step indexing.\n   * @param {string} initialStep - The name of the step to start at.\n   */\n  constructor(model = [], circular = false, initialStep) {\n    this.steps = model;\n    this.currentStep = initialStep ? initialStep : model[0].name || model[0];\n    this.circular = circular;\n  }\n\n  /**\n   * Get the length of steps.\n   * @return {number} The length of the steps array.\n   */\n  get length() {\n    return this.steps.length;\n  }\n\n  /**\n   * Get the 1 based index of active step.\n   * @return {number} 1 based index of active step.\n   */\n  get currentStepIndex() {\n    // 1 based\n    return this.currentIndex + 1;\n  }\n\n  /**\n   * Get the 0 based index of active step.\n   * @return {number} 0 based index of active step.\n   */\n  get currentIndex() {\n    // 0 based\n    return this.steps.findIndex((step) => {\n      let name = step.name || step;\n      return name === this.currentStep;\n    });\n  }\n\n  /**\n   * Get the name for the first step item.\n   * @return {string} Name of first step item.\n   */\n  get firstStepName() {\n    const firstNode = this.steps[0];\n\n    return firstNode.name || firstNode;\n  }\n\n  /**\n   * Get the active step item.\n   * @return {string|Object} The active step item.\n   */\n  get currentStepNode() {\n    return this.steps.find(\n      (stepNode) => (stepNode.name || stepNode) === this.currentStep\n    );\n  }\n\n  /**\n   * Validate if step is active by name.\n   * @param {string} name - Name of step to check.\n   * @returns {boolean} If the step is active.\n   */\n  isActive(name) {\n    return this.currentStep === name;\n  }\n\n  /**\n   * Activate step by name.\n   * @param {string} to - Name of step to activate.\n   * @returns {boolean} If the step was activated.\n   */\n  transitionTo(to) {\n    const destination = to.name || to;\n\n    if (destination && destination !== this.currentStep) {\n      return this.activate(destination);\n    }\n\n    return false;\n  }\n\n  /**\n   * Activate the next step.\n   * @returns {boolean} If the next step is activated.\n   */\n  transitionToNext() {\n    const to = this.pickNext();\n\n    return this.transitionTo(to);\n  }\n\n  /**\n   * Activate the previous step.\n   * @returns {boolean} If the previous step is activated.\n   */\n  transitionToPrevious() {\n    const to = this.pickPrevious();\n\n    return this.transitionTo(to);\n  }\n\n  /**\n   * Set current step by name.\n   * @param {string|Object} step\n   * @param {string} step[].name - The name of the step, if an Object.\n   * @returns {boolean} If step is activated, without error.\n   */\n  activate(step) {\n    const name = step.name || step;\n    this.currentStep = name;\n\n    return true;\n  }\n\n  /**\n   * Get the next available step item.\n   * Note: If in circular mode, it will always return a step.\n   * @returns {boolean|string} The next step if available or false.\n   */\n  pickNext() {\n    const currentNode = this.steps[this.incrementIndex()];\n\n    if (currentNode) {\n      return currentNode.name || currentNode;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the previous available step item.\n   * Note: If in circular mode, it will always return a step.\n   * @returns {boolean|string} The previous step if available or false.\n   */\n  pickPrevious() {\n    const currentNode = this.steps[this.incrementIndex(-1)];\n\n    if (currentNode) {\n      return currentNode.name || currentNode;\n    }\n\n    return false;\n  }\n\n  /**\n   * Increment the index.\n   * Note: If in circular mode, it will always return an in bounds index.\n   * @param {number} increment - The value to increment by.\n   * @returns {number} The index after increment.\n   */\n  incrementIndex(increment = 1) {\n    let l = this.length;\n    let i = this.currentIndex + increment;\n\n    if (this.circular) {\n      i = ((i % l) + l) % l;\n    }\n\n    return i;\n  }\n\n  /**\n   * Get the 1 based index of the step by name.\n   * @param {string} nameQuery - The name of the step to check.\n   * @returns {number} The index of the step if available.\n   */\n  getIndex(nameQuery) {\n    return (\n      this.steps.findIndex((step) => {\n        let name = step.name || step;\n        return name === nameQuery;\n      }) + 1\n    );\n  }\n\n  /**\n   * Required by Alpine for automatic execution.\n   */\n  init() {}\n}\n\n/**\n * StepsController as a plain js object.\n * \n * @typedef {Object} StepsControllerObject\n * @property {string[]|Object[]} steps - Step items.\n * @property {string} currentStep - The name of the active step item.\n * @property {boolean} circular - If circular indexing is enabled.\n * @property {number} length - The length of the steps items.\n * @property {number} currentStepIndex - 1 based index of active step.\n * @property {number} currentIndex - 0 based index of active step.\n * @property {string} firstStepName - Name of first step item.\n * @property {string|Object} currentStepNode - The active step item.\n * @property {function(string=):boolean} isActive - Validate if step is active by name.\n * @property {function(string=):boolean} transitionTo - Activate step by name.\n * @property {function():boolean} transitionToNext - Activate the next step.\n * @property {function():boolean} transitionToPrevious - Activate the previous step.\n * @property {function(string=):boolean} activate - Set current step by name.\n * @property {function():boolean|string} pickNext - Get the next available step item.\n * @property {function():boolean|string} pickPrevious - Get the previous available step item.\n * @property {function(number=):number} incrementIndex - Increment the index.\n * @property {function(string=):number} getIndex - Get the 1 based index of the step by name.\n * @property {function():void} init - Required by Alpine for automatic execution.\n */\nvar StepsControllerObject;\n\n/**\n * Callback function for building a steps controller as a plain js object.\n *\n * [Usage Example]{@tutorial basic_usage.html}\n *\n * @function StepsComponent\n * @param {string[]|Object[]} model - Step items.\n * @param {boolean} circular - Allow circular step indexing.\n * @param {string} initialStep - Name of step to start with.\n * @returns {StepsControllerObject} A {@link StepsControllerObject} object\n */\nexport const StepsComponent = (model = [], circular = false, initialStep) => ({\n  steps: model,\n  circular: circular,\n  currentStep: initialStep ? initialStep : model[0].name || model[0],\n  get length() {\n    return this.steps.length;\n  },\n  get currentStepIndex() {\n    return this.currentIndex + 1;\n  },\n  get currentIndex() {\n    return this.steps.findIndex((step) => {\n      let name = step.name || step;\n      return name === this.currentStep;\n    });\n  },\n  get firstStepName() {\n    const firstNode = this.steps[0];\n\n    return firstNode.name || firstNode;\n  },\n  get currentStepNode() {\n    return this.steps.find(\n      (stepNode) => (stepNode.name || stepNode) === this.currentStep\n    );\n  },\n  isActive(name) {\n    return this.currentStep === name;\n  },\n  transitionTo(to) {\n    const destination = to.name || to;\n\n    if (destination && destination !== this.currentStep) {\n      this.activate(destination);\n    }\n\n    return false;\n  },\n  transitionToNext() {\n    const to = this.pickNext();\n\n    return this.transitionTo(to);\n  },\n  transitionToPrevious() {\n    const to = this.pickPrevious();\n\n    return this.transitionTo(to);\n  },\n  activate(step) {\n    const name = step.name || step;\n\n    if (this.getIndex(name) <= 0) {\n      return false;\n    }\n\n    this.currentStep = name;\n\n    return true;\n  },\n  pickNext() {\n    const currentNode = this.steps[this.incrementIndex()];\n\n    if (currentNode) {\n      return currentNode.name || currentNode;\n    }\n\n    return false;\n  },\n  pickPrevious() {\n    const currentNode = this.steps[this.incrementIndex(-1)];\n\n    if (currentNode) {\n      return currentNode.name || currentNode;\n    }\n\n    return false;\n  },\n  incrementIndex(increment = 1) {\n    let l = this.length;\n    let i = this.currentIndex + increment;\n\n    if (this.circular) {\n      i = ((i % l) + l) % l;\n    }\n\n    return i;\n  },\n  getIndex(nameQuery) {\n    return (\n      this.steps.findIndex((step) => {\n        let name = step.name || step;\n        return name === nameQuery;\n      }) + 1\n    );\n  },\n  init() {},\n});"],"names":["model","circular","initialStep","steps","currentStep","name","length","this","currentStepIndex","currentIndex","findIndex","step","firstStepName","firstNode","currentStepNode","find","stepNode","isActive","transitionTo","to","destination","activate","transitionToNext","pickNext","transitionToPrevious","pickPrevious","getIndex","currentNode","incrementIndex","increment","l","i","nameQuery","init","constructor"],"mappings":";;;;;oQA4O8B,CAACA,EAAQ,GAAIC,GAAW,EAAOC,KAAiB,CAC5EC,MAAOH,EACPC,SAAUA,EACVG,YAAaF,IAA4BF,EAAM,GAAGK,MAAQL,EAAM,IAC5DM,aACF,OAAOC,KAAKJ,MAAMG,MALwD,EAOxEE,uBACF,OAAOD,KAAKE,aAAe,CAR+C,EAUxEA,mBACF,OAAOF,KAAKJ,MAAMO,WAAWC,IAChBA,EAAKN,MAAQM,KACRJ,KAAKH,aAbmD,EAgBxEQ,oBACF,MAAMC,EAAYN,KAAKJ,MAAM,GAE7B,OAAOU,EAAUR,MAAQQ,CAnBiD,EAqBxEC,sBACF,OAAOP,KAAKJ,MAAMY,MACfC,IAAcA,EAASX,MAAQW,KAAcT,KAAKH,aAvBqB,EA0B5Ea,SAASZ,GACP,OAAOE,KAAKH,cAAgBC,CA3B8C,EA6B5Ea,aAAaC,GACX,MAAMC,EAAcD,EAAGd,MAAQc,EAM/B,OAJIC,GAAeA,IAAgBb,KAAKH,aACtCG,KAAKc,SAASD,IAGT,CApCmE,EAsC5EE,mBACE,MAAMH,EAAKZ,KAAKgB,WAEhB,OAAOhB,KAAKW,aAAaC,EAzCiD,EA2C5EK,uBACE,MAAML,EAAKZ,KAAKkB,eAEhB,OAAOlB,KAAKW,aAAaC,EA9CiD,EAgD5EE,SAASV,GACP,MAAMN,EAAOM,EAAKN,MAAQM,EAE1B,QAAIJ,KAAKmB,SAASrB,IAAS,KAI3BE,KAAKH,YAAcC,GAEZ,EAzDmE,EA2D5EkB,WACE,MAAMI,EAAcpB,KAAKJ,MAAMI,KAAKqB,kBAEpC,QAAID,IACKA,EAAYtB,MAAQsB,EA/D6C,EAoE5EF,eACE,MAAME,EAAcpB,KAAKJ,MAAMI,KAAKqB,gBAAgB,IAEpD,QAAID,IACKA,EAAYtB,MAAQsB,EAxE6C,EA6E5EC,eAAeC,EAAY,GACzB,IAAIC,EAAIvB,KAAKD,OACTyB,EAAIxB,KAAKE,aAAeoB,EAM5B,OAJItB,KAAKN,WACP8B,GAAMA,EAAID,EAAKA,GAAKA,GAGfC,CArFmE,EAuF5EL,SAASM,GACP,OACEzB,KAAKJ,MAAMO,WAAWC,IACTA,EAAKN,MAAQM,KACRqB,IACb,CA5FmE,EA+F5EC,OAAS,sBA9TJ,MAQLC,YAAYlC,EAAQ,GAAIC,GAAW,EAAOC,GACxCK,KAAKJ,MAAQH,EACbO,KAAKH,YAAcF,IAA4BF,EAAM,GAAGK,MAAQL,EAAM,IACtEO,KAAKN,SAAWA,CACjB,CAMGK,aACF,OAAOC,KAAKJ,MAAMG,MACnB,CAMGE,uBAEF,OAAOD,KAAKE,aAAe,CAC5B,CAMGA,mBAEF,OAAOF,KAAKJ,MAAMO,WAAWC,IAChBA,EAAKN,MAAQM,KACRJ,KAAKH,aAExB,CAMGQ,oBACF,MAAMC,EAAYN,KAAKJ,MAAM,GAE7B,OAAOU,EAAUR,MAAQQ,CAC1B,CAMGC,sBACF,OAAOP,KAAKJ,MAAMY,MACfC,IAAcA,EAASX,MAAQW,KAAcT,KAAKH,aAEtD,CAODa,SAASZ,GACP,OAAOE,KAAKH,cAAgBC,CAC7B,CAODa,aAAaC,GACX,MAAMC,EAAcD,EAAGd,MAAQc,EAE/B,SAAIC,GAAeA,IAAgBb,KAAKH,cAC/BG,KAAKc,SAASD,EAIxB,CAMDE,mBACE,MAAMH,EAAKZ,KAAKgB,WAEhB,OAAOhB,KAAKW,aAAaC,EAC1B,CAMDK,uBACE,MAAML,EAAKZ,KAAKkB,eAEhB,OAAOlB,KAAKW,aAAaC,EAC1B,CAQDE,SAASV,GACP,MAAMN,EAAOM,EAAKN,MAAQM,EAG1B,OAFAJ,KAAKH,YAAcC,GAEZ,CACR,CAODkB,WACE,MAAMI,EAAcpB,KAAKJ,MAAMI,KAAKqB,kBAEpC,QAAID,IACKA,EAAYtB,MAAQsB,EAI9B,CAODF,eACE,MAAME,EAAcpB,KAAKJ,MAAMI,KAAKqB,gBAAgB,IAEpD,QAAID,IACKA,EAAYtB,MAAQsB,EAI9B,CAQDC,eAAeC,EAAY,GACzB,IAAIC,EAAIvB,KAAKD,OACTyB,EAAIxB,KAAKE,aAAeoB,EAM5B,OAJItB,KAAKN,WACP8B,GAAMA,EAAID,EAAKA,GAAKA,GAGfC,CACR,CAODL,SAASM,GACP,OACEzB,KAAKJ,MAAMO,WAAWC,IACTA,EAAKN,MAAQM,KACRqB,IACb,CAER,CAKDC,OAAS"}