/*!
  * Alpine Steps v1.0.0 (https://github.com/ivanmucyongabo/alpine-steps#readme)
  * Copyright 2021-2022 Ivan Mucyo Ngabo
  * Licensed under MIT (https://github.com/ivanmucyongabo/alpinejs-steps/blob/main/LICENSE)
  */
class t{constructor(t=[],e=!1,n){this.steps=t,this.currentStep=n||(t[0].name||t[0]),this.circular=e}get length(){return this.steps.length}get currentStepIndex(){return this.currentIndex+1}get currentIndex(){return this.steps.findIndex((t=>(t.name||t)===this.currentStep))}get firstStepName(){const t=this.steps[0];return t.name||t}get currentStepNode(){return this.steps.find((t=>(t.name||t)===this.currentStep))}isActive(t){return this.currentStep===t}transitionTo(t){const e=t.name||t;return!(!e||e===this.currentStep)&&this.activate(e)}transitionToNext(){const t=this.pickNext();return this.transitionTo(t)}transitionToPrevious(){const t=this.pickPrevious();return this.transitionTo(t)}activate(t){const e=t.name||t;return this.currentStep=e,!0}pickNext(){const t=this.steps[this.incrementIndex()];return!!t&&(t.name||t)}pickPrevious(){const t=this.steps[this.incrementIndex(-1)];return!!t&&(t.name||t)}incrementIndex(t=1){let e=this.length,n=this.currentIndex+t;return this.circular&&(n=(n%e+e)%e),n}getIndex(t){return this.steps.findIndex((e=>(e.name||e)===t))+1}init(){}}const e=(t=[],e=!1,n)=>({steps:t,circular:e,currentStep:n||(t[0].name||t[0]),get length(){return this.steps.length},get currentStepIndex(){return this.currentIndex+1},get currentIndex(){return this.steps.findIndex((t=>(t.name||t)===this.currentStep))},get firstStepName(){const t=this.steps[0];return t.name||t},get currentStepNode(){return this.steps.find((t=>(t.name||t)===this.currentStep))},isActive(t){return this.currentStep===t},transitionTo(t){const e=t.name||t;return e&&e!==this.currentStep&&this.activate(e),!1},transitionToNext(){const t=this.pickNext();return this.transitionTo(t)},transitionToPrevious(){const t=this.pickPrevious();return this.transitionTo(t)},activate(t){const e=t.name||t;return this.currentStep=e,!0},pickNext(){const t=this.steps[this.incrementIndex()];return!!t&&(t.name||t)},pickPrevious(){const t=this.steps[this.incrementIndex(-1)];return!!t&&(t.name||t)},incrementIndex(t=1){let e=this.length,n=this.currentIndex+t;return this.circular&&(n=(n%e+e)%e),n},getIndex(t){return this.steps.findIndex((e=>(e.name||e)===t))+1},init(){}});export{e as StepsComponent,t as StepsController};
//# sourceMappingURL=steps.esm.min.js.map
